import { Transaction, TransactionOnNetwork } from '@multiversx/sdk-core';
import { TypedValue, Type, OptionValue, OptionalValue, List, VariadicValue, CompositeValue, StringValue, U8Value, U16Value, U32Value, U64Value, BigUIntValue, BooleanValue, AddressValue, TokenIdentifierValue, BytesValue, TokenTransfer, Struct, CodeMetadataValue, NothingValue, Transaction as Transaction$1, Address, ApiNetworkProvider } from '@multiversx/sdk-core/out';
import QRCodeStyling from 'qr-code-styling';

type ChainEnv = 'mainnet' | 'testnet' | 'devnet';
type ProtocolName = 'warp' | 'brand' | 'abi';
type WarpConfig = {
    env: ChainEnv;
    clientUrl?: string;
    currentUrl?: string;
    userAddress?: string;
    chainApiUrl?: string;
    warpSchemaUrl?: string;
    brandSchemaUrl?: string;
    cacheTtl?: number;
    registryContract?: string;
    indexUrl?: string;
    indexApiKey?: string;
    indexSearchParamName?: string;
    vars?: Record<string, string | number>;
};
type WarpCacheConfig = {
    ttl?: number;
};
type TrustStatus = 'unverified' | 'verified' | 'blacklisted';
type RegistryInfo = {
    hash: string;
    alias: string | null;
    trust: TrustStatus;
    creator: string;
    createdAt: number;
    brand: string | null;
    upgrade: string | null;
};
type WarpIdType = 'hash' | 'alias';
type WarpVarPlaceholder = string;
type Warp = {
    protocol: string;
    name: string;
    title: string;
    description: string | null;
    bot?: string;
    preview?: string;
    vars?: Record<WarpVarPlaceholder, string>;
    actions: WarpAction[];
    next?: string;
    meta?: WarpMeta;
};
type WarpMeta = {
    hash: string;
    creator: string;
    createdAt: string;
};
type WarpAction = WarpTransferAction | WarpContractAction | WarpQueryAction | WarpCollectAction | WarpLinkAction;
type WarpActionType = 'transfer' | 'contract' | 'query' | 'collect' | 'link';
type WarpTransferAction = {
    type: WarpActionType;
    label: string;
    description?: string | null;
    address?: string;
    args?: string[];
    value?: string;
    transfers?: WarpContractActionTransfer[];
    inputs?: WarpActionInput[];
    next?: string;
};
type WarpContractAction = {
    type: WarpActionType;
    label: string;
    description?: string | null;
    address: string;
    func: string | null;
    args: string[];
    value?: string;
    gasLimit: number;
    transfers?: WarpContractActionTransfer[];
    inputs?: WarpActionInput[];
    next?: string;
};
type WarpContractActionTransfer = {
    token: string;
    nonce?: number;
    amount?: string;
};
type WarpLinkAction = {
    type: WarpActionType;
    label: string;
    description?: string | null;
    url: string;
    inputs?: WarpActionInput[];
};
type WarpQueryAction = {
    type: WarpActionType;
    label: string;
    description?: string | null;
    address: string;
    func: string;
    args: string[];
    abi?: string;
    inputs?: WarpActionInput[];
};
type WarpCollectAction = {
    type: WarpActionType;
    label: string;
    description?: string | null;
    destination: {
        url: string;
        method: 'GET' | 'POST';
        headers: Record<string, string>;
    };
    inputs?: WarpActionInput[];
    next?: string;
};
type WarpActionInputSource = 'field' | 'query';
type BaseWarpActionInputType = 'string' | 'uint8' | 'uint16' | 'uint32' | 'uint64' | 'biguint' | 'bool' | 'address' | 'token' | 'codemeta' | 'hex' | 'esdt' | 'nft';
type WarpActionInputType = string;
type WarpActionInputPosition = 'receiver' | 'value' | 'transfer' | `arg:${1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10}`;
type WarpActionInputModifier = 'scale';
type WarpActionInput = {
    name: string;
    as?: string;
    description?: string | null;
    bot?: string;
    type: WarpActionInputType;
    position: WarpActionInputPosition;
    source: WarpActionInputSource;
    required?: boolean;
    min?: number | WarpVarPlaceholder;
    max?: number | WarpVarPlaceholder;
    pattern?: string;
    patternDescription?: string;
    options?: string[];
    modifier?: string;
};
type WarpActionExecutionResult = {
    action: WarpAction;
    user: {
        address: string;
    };
    tx?: string;
};
type WarpContract = {
    address: string;
    owner: string;
    verified: boolean;
};
type WarpContractVerification = {
    codeHash: string;
    abi: object;
};
type Brand = {
    protocol: string;
    name: string;
    description: string;
    logo: string;
    urls?: BrandUrls;
    colors?: BrandColors;
    cta?: BrandCta;
    meta?: BrandMeta;
};
type BrandUrls = {
    web?: string;
};
type BrandColors = {
    primary?: string;
    secondary?: string;
};
type BrandCta = {
    title: string;
    description: string;
    label: string;
    url: string;
};
type BrandMeta = {
    hash: string;
    creator: string;
    createdAt: string;
};
type WarpSearchResult = {
    hits: WarpSearchHit[];
};
type WarpSearchHit = {
    hash: string;
    alias: string;
    name: string;
    title: string;
    description: string;
    preview: string;
    status: string;
    category: string;
    featured: boolean;
};
type WarpAbi = {
    protocol: string;
    content: AbiContents;
    meta?: WarpMeta;
};
type AbiContents = {
    name?: string;
    constructor?: any;
    upgradeConstructor?: any;
    endpoints?: any[];
    types?: Record<string, any>;
    events?: any[];
};

declare class BrandBuilder {
    private config;
    private pendingBrand;
    constructor(config: WarpConfig);
    createInscriptionTransaction(brand: Brand): Transaction;
    createFromRaw(encoded: string, validateSchema?: boolean): Promise<Brand>;
    createFromTransaction(tx: TransactionOnNetwork, validateSchema?: boolean): Promise<Brand>;
    createFromTransactionHash(hash: string): Promise<Brand | null>;
    setName(name: string): BrandBuilder;
    setDescription(description: string): BrandBuilder;
    setLogo(logo: string): BrandBuilder;
    setUrls(urls: BrandUrls): BrandBuilder;
    setColors(colors: BrandColors): BrandBuilder;
    setCta(cta: BrandCta): BrandBuilder;
    build(): Promise<Brand>;
    private ensure;
    private ensureValidSchema;
}

declare const WarpProtocolVersions: {
    Warp: string;
    Brand: string;
    Abi: string;
};
declare const Config: {
    LatestWarpSchemaUrl: string;
    LatestBrandSchemaUrl: string;
    DefaultClientUrl: (env: ChainEnv) => "https://usewarp.to" | "https://testnet.usewarp.to" | "https://devnet.usewarp.to";
    SuperClientUrls: string[];
    Chain: {
        ApiUrl: (env: ChainEnv) => "https://devnet-api.multiversx.com" | "https://testnet-api.multiversx.com" | "https://api.multiversx.com";
    };
    Registry: {
        Contract: (env: ChainEnv) => "erd1qqqqqqqqqqqqqpgqje2f99vr6r7sk54thg03c9suzcvwr4nfl3tsfkdl36" | "####" | "erd1qqqqqqqqqqqqqpgq3mrpj3u6q7tejv6d7eqhnyd27n9v5c5tl3ts08mffe";
    };
    AvailableActionInputSources: WarpActionInputSource[];
    AvailableActionInputTypes: WarpActionInputType[];
    AvailableActionInputPositions: WarpActionInputPosition[];
};

declare const WarpConstants: {
    HttpProtocolPrefix: string;
    IdentifierParamName: string;
    IdentifierParamSeparator: string;
    IdentifierType: {
        Alias: string;
        Hash: string;
    };
    ArgParamsSeparator: string;
    ArgCompositeSeparator: string;
    Egld: {
        Identifier: string;
        DisplayName: string;
        Decimals: number;
    };
};

declare const getChainId: (env: ChainEnv) => string;
declare const getLatestProtocolIdentifier: (name: ProtocolName) => string;
declare const getWarpActionByIndex: (warp: Warp, index: number) => WarpAction;
declare const toTypedRegistryInfo: (registryInfo: any) => RegistryInfo;
declare const shiftBigintBy: (value: bigint | string, decimals: number) => bigint;
declare const toPreviewText: (text: string, maxChars?: number) => string;

declare const option: (value: TypedValue | null, type?: Type) => OptionValue;
declare const optional: (value: TypedValue | null, type?: Type) => OptionalValue;
declare const list: (values: TypedValue[]) => List;
declare const variadic: (values: TypedValue[]) => VariadicValue;
declare const composite: (values: TypedValue[]) => CompositeValue;
declare const string: (value: string) => StringValue;
declare const u8: (value: number) => U8Value;
declare const u16: (value: number) => U16Value;
declare const u32: (value: number) => U32Value;
declare const u64: (value: bigint) => U64Value;
declare const biguint: (value: bigint | string | number) => BigUIntValue;
declare const boolean: (value: boolean) => BooleanValue;
declare const address: (value: string) => AddressValue;
declare const token: (value: string) => TokenIdentifierValue;
declare const hex: (value: string) => BytesValue;
declare const esdt: (value: TokenTransfer) => Struct;
declare const codemeta: (hexString: string) => CodeMetadataValue;
declare const nothing: () => NothingValue;

declare class WarpAbiBuilder {
    private config;
    private cache;
    constructor(config: WarpConfig);
    createInscriptionTransaction(abi: AbiContents): Transaction;
    createFromRaw(encoded: string): Promise<WarpAbi>;
    createFromTransaction(tx: TransactionOnNetwork): Promise<WarpAbi>;
    createFromTransactionHash(hash: string, cache?: WarpCacheConfig): Promise<WarpAbi | null>;
}

declare class WarpActionExecutor {
    private config;
    private url;
    private serializer;
    private contractLoader;
    constructor(config: WarpConfig);
    createTransactionForExecute(action: WarpTransferAction | WarpContractAction, inputs: string[]): Promise<Transaction$1>;
    executeQuery(action: WarpQueryAction, inputs: string[]): Promise<TypedValue>;
    executeCollect(action: WarpCollectAction, inputs: Record<string, any>, meta?: Record<string, any>): Promise<void>;
    getTxComponentsFromInputs(action: WarpTransferAction | WarpContractAction | WarpQueryAction, inputs: string[], sender?: Address): Promise<{
        destination: Address;
        args: string[];
        value: bigint;
        transfers: TokenTransfer[];
    }>;
    private getModifiedInputs;
    private getResolvedInputs;
    private preprocessInput;
    private getPreparedArgs;
    private getAbiForAction;
    private fetchAbi;
    private toTypedTransfer;
}

type WarpNativeValue = string | number | bigint | boolean | null | TokenTransfer | WarpNativeValue[];
declare class WarpArgSerializer {
    nativeToString(type: WarpActionInputType, value: WarpNativeValue): string;
    typedToString(value: TypedValue): string;
    typedToNative(value: TypedValue): [WarpActionInputType, WarpNativeValue];
    nativeToTyped(type: WarpActionInputType, value: WarpNativeValue): TypedValue;
    nativeToType(type: BaseWarpActionInputType): Type;
    stringToNative(value: string): [WarpActionInputType, WarpNativeValue];
    stringToTyped(value: string): TypedValue;
    typeToNative(type: Type): BaseWarpActionInputType;
}

declare class WarpBuilder {
    private config;
    private cache;
    private pendingWarp;
    constructor(config: WarpConfig);
    createInscriptionTransaction(warp: Warp): Transaction;
    createFromRaw(encoded: string, validate?: boolean): Promise<Warp>;
    createFromTransaction(tx: TransactionOnNetwork, validate?: boolean): Promise<Warp>;
    createFromTransactionHash(hash: string, cache?: WarpCacheConfig): Promise<Warp | null>;
    setName(name: string): WarpBuilder;
    setTitle(title: string): WarpBuilder;
    setDescription(description: string): WarpBuilder;
    setPreview(preview: string): WarpBuilder;
    setActions(actions: WarpAction[]): WarpBuilder;
    addAction(action: WarpAction): WarpBuilder;
    build(): Promise<Warp>;
    getDescriptionPreview(description: string, maxChars?: number): string;
    private ensure;
}

declare class WarpContractLoader {
    private readonly config;
    constructor(config: WarpConfig);
    getContract(address: string): Promise<WarpContract | null>;
    getVerificationInfo(address: string): Promise<WarpContractVerification | null>;
}

declare class WarpIndex {
    private config;
    constructor(config: WarpConfig);
    search(query: string): Promise<WarpSearchHit[]>;
}

type DetectionResult = {
    match: boolean;
    url: string;
    warp: Warp | null;
    registryInfo: RegistryInfo | null;
    brand: Brand | null;
};
type DetectionResultFromHtml = {
    match: boolean;
    results: {
        url: string;
        warp: Warp;
    }[];
};
declare class WarpLink {
    private config;
    constructor(config: WarpConfig);
    isValid(url: string): boolean;
    detectFromHtml(content: string): Promise<DetectionResultFromHtml>;
    detect(url: string): Promise<DetectionResult>;
    build(type: WarpIdType, id: string): string;
    generateQrCode(type: WarpIdType, id: string, size?: number, background?: string, color?: string, logoColor?: string): QRCodeStyling;
    private extractIdentifierInfoFromUrl;
}

declare class WarpRegistry {
    private config;
    private cache;
    unitPrice: bigint;
    constructor(config: WarpConfig);
    init(): Promise<void>;
    createWarpRegisterTransaction(txHash: string, alias?: string | null): Transaction$1;
    createWarpUnregisterTransaction(txHash: string): Transaction$1;
    createWarpUpgradeTransaction(alias: string, txHash: string): Transaction$1;
    createWarpAliasSetTransaction(txHash: string, alias: string): Transaction$1;
    createBrandRegisterTransaction(txHash: string): Transaction$1;
    createWarpPublishTransaction(txHash: string): Transaction$1;
    createWarpBrandingTransaction(warpHash: string, brandHash: string): Transaction$1;
    getInfoByAlias(alias: string, cache?: WarpCacheConfig): Promise<{
        registryInfo: RegistryInfo | null;
        brand: Brand | null;
    }>;
    getInfoByHash(hash: string, cache?: WarpCacheConfig): Promise<{
        registryInfo: RegistryInfo | null;
        brand: Brand | null;
    }>;
    getUserWarpRegistryInfos(user?: string): Promise<RegistryInfo[]>;
    getUserBrands(user?: string): Promise<Brand[]>;
    fetchBrand(hash: string, cache?: WarpCacheConfig): Promise<Brand | null>;
    getRegistryContractAddress(): string;
    private loadRegistryConfigs;
    private getFactory;
    private getController;
}

declare class WarpUtils {
    static prepareVars(warp: Warp, config: WarpConfig): Warp;
    static getInfoFromPrefixedIdentifier(prefixedIdentifier: string): {
        type: WarpIdType;
        id: string;
    } | null;
    static getNextStepUrl(warp: Warp, config: WarpConfig): string | null;
    static getConfiguredChainApi(config: WarpConfig): ApiNetworkProvider;
}

export { type AbiContents, type BaseWarpActionInputType, type Brand, BrandBuilder, type BrandColors, type BrandCta, type BrandMeta, type BrandUrls, type ChainEnv, Config, type ProtocolName, type RegistryInfo, type TrustStatus, type Warp, type WarpAbi, WarpAbiBuilder, type WarpAction, type WarpActionExecutionResult, WarpActionExecutor, type WarpActionInput, type WarpActionInputModifier, type WarpActionInputPosition, type WarpActionInputSource, type WarpActionInputType, type WarpActionType, WarpArgSerializer, WarpBuilder, type WarpCacheConfig, type WarpCollectAction, type WarpConfig, WarpConstants, type WarpContract, type WarpContractAction, type WarpContractActionTransfer, WarpContractLoader, type WarpContractVerification, type WarpIdType, WarpIndex, WarpLink, type WarpLinkAction, type WarpMeta, type WarpNativeValue, WarpProtocolVersions, type WarpQueryAction, WarpRegistry, type WarpSearchHit, type WarpSearchResult, type WarpTransferAction, WarpUtils, type WarpVarPlaceholder, address, biguint, boolean, codemeta, composite, esdt, getChainId, getLatestProtocolIdentifier, getWarpActionByIndex, hex, list, nothing, option, optional, shiftBigintBy, string, toPreviewText, toTypedRegistryInfo, token, u16, u32, u64, u8, variadic };
